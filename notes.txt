// review notes

my first read of "Hello Triangle" was really tough to grasp, I honestly don't understand most of it, but the code runs at least. 

for my next session I must re-read "Hello Triangle" and thoroughly take notes of the following concepts: 

  vertex; 
  shader; 
  graphics pipeline; 
  vertex buffer object (vbo); 
  fragment shader; 
  shader program; 
  Linking vertex attributes; 
  vertex array object (vao);
  element buffer objects (ebo)

also try to make sense of the functions 
  glBindBuffer(); 
  glBufferData();
  etc;


==================== graphics pipeline ====================
  it's responsible for transforming all 3D coordinates to 2D pixels that fit on our screen, which is composed of 2 parts: 
    - Transforming 3D coordinates in 2D coordinates
    - Transforming 2d coordinates in colored pixels. 

  there are several steps to producing the 2D colored pixels, and each of them is highly specialized, which can be executed in paralell.
  this goes together with the fact that GPUS contain thousands of small processing cores to quickly process data within the pipeline.
  these cores run small programs on the GPU for each step of the pipeline, which are called shaders.
  some of these shaders are configurable by the developer, which gives us the ability to replace existing default shaders. We must make use of shaders to gain the benefits of reducing CPU strain through GPU usage. 
  shaders in openGL are written in OpenGL shading language (GLSL). 

  pipeline stages: 

  vertex shader -> geometry shader -> shape assembly
  tests/blending -> fragment shader -> rasterization



==================== vertex ====================
 a vertex is a collection of data per 3D coordinate. it can have any atribute we'd like, for the triangle example, we use a vertice (x,y,z) and a color.

  openGL requires the information regarding what we wanna do with the collection of vertexes we provide them. Which primitive are they? 
  some primitives are: 
    GL_POINTS;
    GL_TRIANGLES;
    GL_LINE_STRIP;

==================== vertex shader ====================

the vertex shader is the first part of the pipeline. it receives a single vertex as input and transforms its 3D coordinates into different 3D coordinates (whatever that means)

it allows for some basic processing on the vertex attributes.

the output of the vertex shader is optionally passed to the geometry shader, which takes a collection of vertices that form a primitive and has the ability to generate other shapes by emitting new vertices to form new (or other) primitives. 

==================== primitive assembly ====================

this step of the pipeline can receive the vertices from the vertex or geometry shader (if geometry was skipped) that form one or more primitives and assembles all the points in the primitive shape given. 

==================== rasterization ====================

the rasterization stage maps the primitives the assembly sent it and maps it to the pixels on the screen, resulting in fragments for the fragment shader to use. 

before the fragment shader can run, it performs 'clipping', which is the process of dropping everything that's out of view, increasing performance. 

==================== fragment shader ====================

TLDR: 
  a fragment in openGL is all the data required for openGL to render a single pixel.

the main purpose of the fragment shader is to calculate the final color of a pixel, it analyzes the 3D scene and checks lighting, shadows, etc, to define the current pixel's color.

==================== alpha test / blending ====================

this step consists in checking the depth/stencil value of the fragment and uses them to check if a fragment is in front or behind other objects, discarding them accordingly.
it also checks for alpha values (opacity) to blend objects accordingly. 

so the pixel output from the fragment shader can have a completely different color by the point blending is finished.

==================== functions ====================

glBindBuffer(buffer, object) -> binds a specified buffer into your object
glBufferData(buffer, size, source, draw_kind) -> copies user-defined data into the currently bound buffer

about draw_kind:
  we can specify how we want the GPU to treat the data we're drawing. it can be: 
    GL_STREAM_DRAW -> the data is set only once and used by the GPU only a few times
    GL_STATIC_DRAW -> the data is set only once and use many times.
    GL_DYNAMIC_DRAW -> the data is changed a ot and used many times. 

    glVertexAttribPointer() -> with this function , we can specify to OpenGL how to treat our vertex data in regards to our vertex data. How does our original array of vertices translate to the vec3 in our vertex shader? that's what we tell it.

TLDR; a 'stride' is the space between consecutive vertex attributes.

==================== functions ====================

objects

VBO -> Vertex Buffer Object
  this object stores raw vertex data.

VAO -> Vertex Array Object
  - calls to glEnableVertexAttribArray() or glDisableVertexAttribArray()
  - Vertex attribute configurations via glVertexAttribPointer()
  - Vertex buffer objects associated with vertex attributes by calls to glVertexAttribPointer()

EBO -> Element buffer Object
  - similar to VBO, but stores indices of our vertice data so OpenGL can decide what vertices to draw.


task for tomorrow:
  - refactor the whole code for better modularity (i'll probably use classes) 
  - do exercises 1, 2 and 3

==================== shader stuff ====================

vertex shader -> always receives raw vertice data as input
fragment shader -> always gives a vec4 color output

we can send data from one shader to another if we name the out variable of shader1 as the same as in variable of shader2. the linking handles this

example: 

we could define 

out vec4 vertexColor;
vertexColor = vec4(0.5, 0.0, 0.0, 1.0);

on our vertex shader , and then have:

in vec4 vertexColor;

on our fragment shader

==================== Uniforms ====================

Uniforms are a way to send data from our application to the shader, for example, we could send a color to our fragment shader from within code.

example: 
shader:

uniform vec4 our_color;

code: 

int vertex_color_location = glGetUniformLocation(shader_program, "ourColor");
glUseProgram(shader_program);
glUniform4f(vertex_color_location, 0.0f, 0.0f, 0.0f, 1.0f); -> pass in black color to our_color;

TLDR;
  we don't need to glUseProgram() to get the location of the uniform, but we do need it to set the attribute.
